# РЕСУРСЫ

https://learn.javascript.ru/

# 1.Типы переменных

1. `undefined`, специальное значение особого типа, которое означает отсутствие значения. Undefined активно используется самим JavaScript в самых разных ситуациях, например, при обращении к несуществующему символу строки:

   ```
   const name = 'Arya';
   console.log(name[8]);
   ```

2. `null` - это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

   ```js
   typeof null >>> object
   ```


 3. **Булевый тип** (`boolean`) может принимать только два значения: `true` (истина) и `false` (ложь).

 4. **Строка** (`string`) в JavaScript должна быть заключена в кавычки.

    ```js
    let str = "Привет";
    let str2 = 'Одинарные кавычки тоже подойдут';
    let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
    ```

5. Тип `symbol` (**символ**) используется для создания уникальных идентификаторов в объектах.
6. `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
7. `bigint` для целых чисел произвольной длины.
8. `object` для более сложных структур данных. (массивы, функции, ошибка)

# 	2.Понятие переменных

[Переменная](https://ru.wikipedia.org/wiki/Переменная_(программирование)) – это «именованное хранилище» для данных. Для создания переменной в JavaScript используйте ключевое слово `let`.

Чтобы объявить константную, то есть, неизменяемую переменную, используйте `const` вместо `let`:

```js
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
```

**! В JS принято использовать CamelCase**

# 3.Математические операции в JavaScript

```js
// -, +, *, /, %, **, - бинарные операторы (к 2 переменным)
% остаток от деления

// -, +, Унарные операторы (к 1 переменным)
-1;
-0;
+0;
0;
+"2";       >>>>>> 2
+"2 efwfw"; >>>>> NaN

// Конкатенация + (сложение строк)
"Hello" +"Serg" >>>>> "Hello Serg"
2 + "2"         >>>>> "22"

// Инкремент, декремент
// --, ++
// x++ === (x=x+1)
// ++x === (x=x+1) 
let a=1
console.log(a++)//1
console.log(++a)//3
```

Поддерживаются следующие математические операторы:

- Сложение `+`,
- Вычитание `-`,
- Умножение `*`,
- Деление `/`,
- Взятие остатка от деления `%`,
- Возведение в степень `**`.

Первые четыре оператора очевидны, а про `%` и `**` стоит сказать несколько слов.

## 3.1 [Взятие остатка %](https://learn.javascript.ru/operators#vzyatie-ostatka)

Оператор взятия остатка `%`, несмотря на обозначение.

Результат `a % b` – это [остаток](https://ru.wikipedia.org/wiki/Деление_с_остатком) от целочисленного деления `a` на `b`.

Например:

## 3.2 [Приведение к числу, унарный +](https://learn.javascript.ru/operators#privedenie-k-chislu-unarnyy)

Плюс `+` существует в двух формах: бинарной, которую мы использовали выше, и унарной.

Унарный, то есть применённый к одному значению, плюс `+` ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

Например:

```javascript
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
```

На самом деле это то же самое, что и `Number(...)`, только короче.

Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

Бинарный плюс сложит их как строки:

```javascript
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
```

Поэтому используем унарный плюс, чтобы преобразовать к числу:

```javascript
let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

| Приоритет | Название             | Обозначение |
| :-------- | :------------------- | :---------- |
| …         | …                    | …           |
| 15        | унарный плюс         | `+`         |
| 15        | унарный минус        | `-`         |
| 14        | возведение в степень | `**`        |
| 13        | умножение            | `*`         |
| 13        | деление              | `/`         |
| 12        | сложение             | `+`         |
| 12        | вычитание            | `-`         |
| …         | …                    | …           |
| 2         | присваивание         | `=`         |
| …         | …                    | …           |

Так как «унарный плюс» имеет приоритет `15`, который выше, чем `12` у «сложения» (бинарный плюс), то в выражении `"+apples + +oranges"` сначала выполнятся унарные плюсы, а затем сложени

## 3.3 [Инкремент/декремент](https://learn.javascript.ru/operators#inkrement-dekrement)

Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:

- **Инкремент** `++` увеличивает переменную на 1:

  ```javascript
  let counter = 2;
  counter++;        // работает как counter = counter + 1, просто запись короче
  alert( counter ); // 3
  ```

- **Декремент** `--` уменьшает переменную на 1:

  ```javascript
  let counter = 2;
  counter--;        // работает как counter = counter - 1, просто запись короче
  alert( counter ); // 1
  ```

**Важно:**

Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

- Когда оператор идёт после переменной — это «постфиксная форма»: `counter++`.
- «Префиксная форма» — это когда оператор идёт перед переменной: `++counter`.

Обе эти инструкции делают одно и то же: увеличивают `counter` на `1`.

Есть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают `++/--`.

Давайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

Чтобы увидеть разницу, вот небольшой пример:

```javascript
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

В строке `(*)` *префиксная* форма `++counter` увеличивает `counter` и возвращает новое значение `2`. Так что `alert` покажет `2`.

Теперь посмотрим на постфиксную форму:

```javascript
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
```

В строке `(*)` *постфиксная* форма `counter++` также увеличивает `counter`, но возвращает *старое* значение (которое было до увеличения). Так что `alert` покажет `1`.

Подведём итоги:

- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:

  ```javascript
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, обе строки сделали одно и то же
  ```

- Если хочется тут же использовать результат, то нужна префиксная форма:

  ```javascript
  let counter = 0;
  alert( ++counter ); // 1
  ```

- Если нужно увеличить и при этом получить значение переменной *до увеличения* – нужна постфиксная форма:

  ```javascript
  let counter = 0;
  alert( counter++ ); // 0
  ```

**Инкремент/декремент можно использовать в любых выражениях**

Операторы `++/--` могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.

Например:

```javascript
let counter = 1;
alert( 2 * ++counter ); // 4
```

Сравните с:

```javascript
let counter = 1;
alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение
```

Хотя технически здесь всё в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет множество действий – нехорошо.

При беглом чтении кода можно с лёгкостью пропустить такой `counter++`, и будет неочевидно, что переменная увеличивается.

Лучше использовать стиль «одна строка – одно действие»:

```javascript
let counter = 1;
alert( 2 * counter );
counter++;
```
# 4.Логические операции

<, >, >=, <=, !=, ==, ===, !==

РЕЗУЛЬТАТ ЛИБО `ИСТИНА` ЛИБО `ЛОЖЬ`

```js
console.log(2==='2') >>> false !!!Предпочительние
```

```
console.log(2=='2') >>> true 
```

### 4.1 Составные логические выражения

* И - && (true - когда оба выражения истины) (*умножение)

* ИЛИ - || (+сложение)

### 4.2 Правдивые и ложные значения

JavaScript **автоматически** приводит к истине или ко лжи разные значения типов данных.

Значения, которые **всегда** становятся **ложными**:

- Числе 0 и -0
- Пустая строка - ""
- false
- null
- undefined
- NaN

Все остальные значения автоматически определяются как **истинные**. Среди них в том числе:

- Любое число, отличное от нуля
- Любая строка, содержащая хотя бы 1 символ
- Любой объект или массив

# 5. Условный оператор

if ...else ... else if

```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

# 6. Конструкция "switch"

```js
Конструкция "switch"
Конструкция switch заменяет собой сразу несколько if.

Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

Синтаксис
Конструкция switch имеет один или более блок case и необязательный блок default.

Выглядит она так:

switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default.
Пример работы
Пример использования switch (сработавший код выделен):

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}
Здесь оператор switch последовательно сравнит a со всеми вариантами из case.

Сначала 3, затем – так как нет совпадения – 4. Совпадение найдено, будет выполнен этот вариант, со строки alert( 'В точку!' ) и далее, до ближайшего break, который прервёт выполнение.

Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

Пример без break:

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
  default:
    alert( "Нет таких значений" );
}
```

## Тернарный оператор-это выражение

```js
условие ? выражение1 : выражение2 
```

```js
"The fee is " + (isMember ? "$2.00" : "$10.00")

var firstCheck = false,
    secondCheck = false,
    access = firstCheck ? "Доступ запрещён" : secondCheck ? "Доступ запрещён" : "Доступ разрешён";

console.log( access ); // выводит в консоль "Доступ разрешён"
```

# 7. Массивы как хранилища данных

*Массив* упорядоченная коллекция* данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо:

```js
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива

```

Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: `fruits[-1]`.

**Однако, в JavaScript такая запись не сработает. Её результатом будет `undefined`**

```js
let fruits = ["Apple", "Orange", "Plum"];
// то же самое, что и fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
```

Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

Объявление:

```javascript
// квадратные скобки (обычно)
let arr = [item1, item2...];

// new Array (очень редко)
let arr = new Array(item1, item2...);
```

Вызов `new Array(number)` создаёт массив с заданной длиной, но без элементов.

- Свойство `length` отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
- Если мы уменьшаем `length` вручную, массив укорачивается.

Получение элементов:

- Мы можем получить элемент по его индексу, например `arr[0]`.
- Также мы можем использовать метод `at(i)` для получения элементов с отрицательным индексом, для отрицательных значений `i`, он отступает от конца массива. В остальном он работает так же, как `arr[i]`, если `i >= 0`.

Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

- `push(...items)`добавляет `items` в конец массива.
- `pop()` удаляет элемент в конце массива и возвращает его.
- `shift()` удаляет элемент в начале массива и возвращает его.
- `unshift(...items)` добавляет `items` в начало массива.

Чтобы пройтись по элементам массива:

- `for (let i=0; i<arr.length; i++)` – работает быстрее всего, совместим со старыми браузерами.
- `for (let item of arr)` – современный синтаксис только для значений элементов (к индексам нет доступа).
- `for (let i in arr)` – никогда не используйте для массивов!

Мы вернёмся к массивам и изучим другие методы добавления, удаления, выделения элементов и сортировки массивов в главе: [Методы массивов](https://learn.javascript.ru/array-methods).

## 7.1 [Перебор элементов](https://learn.javascript.ru/array#perebor-elementov)

Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

Но для массивов возможен и другой вариант цикла, `for..of`:

```javascript
let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}
```

Цикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.

Технически, так как массив является объектом, можно использовать и вариант `for..in`:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
```

Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

1. Цикл `for..in` выполняет перебор *всех свойств* объекта, а не только цифровых.

   В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые *выглядят, как массив*. То есть, у них есть свойство `length` и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл `for..in` выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

2. Цикл `for..in` оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

В общем, не следует использовать цикл `for..in` для массивов.

### 7.1.1 while

**Оператор while** создаёт цикл, выполняющий заданную инструкцию, пока истинно проверяемое условие. Логическое значение условия вычисляется перед исполнением тела цикла.

## [Синтаксис](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/while#синтаксис)

```
while (условие) {
  инструкция
}
```

- `условие`

  Выражение, логическое значение которого проверяется каждый раз перед заходом в цикл. Если значение истинно, то исполняется `инструкция`. Когда значение становится ложным, выполняется код, следующий за циклом `while`.

- `инструкция`

  Инструкция, которая исполняется каждый раз, пока истинно условие. Чтобы выполнить несколько инструкций в цикле, используйте [блочный](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block) оператор (`{ ... }`) для их группировки.

## [Примеры](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/while#примеры)

Следующий цикл `while` исполняется, пока `n` не превышает трёх.

```
var n = 0;
var x = 0;

while (n < 3) {
  n++;
  x += n;
}
```

# !!. Понятие DOM и его место в браузере

**DOM (Document Object Model)**
Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

**Объектная модель браузера (Browser Object Model, BOM)** – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.